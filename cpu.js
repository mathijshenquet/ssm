// Generated by CoffeeScript 1.6.2
(function() {
  var HP, MP, MemoryBank, PC, RR, SP, binOp, binPred, global;

  if (typeof global === "undefined" || global === null) {
    global = window;
  }

  binOp = function(op) {
    var fn, lbl;

    fn = new Function("a, b", "return a " + op + " b");
    lbl = new Function("a, b", "return '('+a+' " + op + " '+b+')';");
    return {
      label: function(newLabel) {
        var a, b, label, value;

        b = this.popCmt();
        a = this.popCmt();
        value = fn(a.value, b.value);
        label = (a.label != null) && (b.label != null) ? lbl(a.label, b.label) : void 0;
        return this.push(value, newLabel != null ? newLabel : label);
      },
      normal: function() {
        var a, b;

        b = this.pop();
        a = this.pop();
        return this.push(fn(a, b));
      }
    };
  };

  binPred = function(op) {
    var fn, lbl;

    fn = new Function("a, b", "return (a " + op + " b) ? 1 : -1");
    lbl = new Function("a, b", "return '('+a+' " + op + " '+b+')';");
    return {
      label: function() {
        var a, b, label, value;

        b = this.popCmt();
        a = this.popCmt();
        value = fn(a.value, b.value);
        label = (a.label != null) && (b.label != null) ? lbl(a.label, b.label) : void 0;
        return this.push(value, typeof newLabel !== "undefined" && newLabel !== null ? newLabel : label);
      },
      normal: function() {
        var a, b;

        b = this.pop();
        a = this.pop();
        return this.push(fn(a, b));
      }
    };
  };

  global.SSMInstructionSet = {
    add: binOp("+"),
    sub: binOp("-"),
    mul: binOp("*"),
    div: binOp("/"),
    mod: binOp("%"),
    neg: {
      normal: function() {
        return this.push(-this.pop());
      },
      label: function(newLabel) {
        var label, value, _ref;

        _ref = this.popCmt(), value = _ref.value, label = _ref.label;
        return this.push(-value, "-(" + (newLabel != null ? newLabel : label) + ")");
      }
    },
    eq: binPred("=="),
    ne: binPred("!="),
    lt: binPred("<"),
    gt: binPred(">"),
    le: binPred("<="),
    ge: binPred(">="),
    or: binOp("|"),
    xor: binOp("^"),
    not: {
      normal: function() {
        return this.push(this.pop() ^ 0xFFFF);
      },
      label: function(newLabel) {
        ({
          value: value,
          label: label
        });
        return this.push(value ^ 0xFFFF, "!(" + (newLabel != null ? newLabel : a.label) + ")");
      }
    },
    ldc: {
      normal: function(a) {
        return this.push(a);
      },
      label: function(a, newLabel) {
        return this.push(a, newLabel != null ? newLabel : a);
      }
    },
    ldr: {
      normal: function(regHandle) {
        var id;

        id = this.regId(regHandle);
        return this.push(this.reg.int[id]);
      },
      label: function(regHandle, newLabel) {
        var id;

        id = this.regId(regHandle);
        this.push(this.reg.int[id], newLabel != null ? newLabel : this.reg.label[id]);
        return this.reg.read[id] = true;
      }
    },
    str: {
      normal: function(regHandle) {
        return this.reg.int[this.regId(regHandle)] = this.pop();
      },
      label: function(regHandle, newLabel) {
        var label, value, _ref;

        _ref = this.popCmt(), value = _ref.value, label = _ref.label;
        return this.set(this.regId(regHandle), value, newLabel != null ? newLabel : label);
      }
    },
    lds: {
      normal: function(n) {
        return this.mem.read[this.r[SP] + n] = true;
      },
      label: function(n, newLabel) {
        var addr;

        addr = this.r[SP] + n;
        this.push(this.read(addr), newLabel != null ? newLabel : this.mem.label[addr]);
        return this.mem.read[addr] = true;
      }
    },
    sts: {
      normal: function(n) {
        var value;

        value = this.pop();
        return this.write(this.r[SP] + (n + 1), value);
      },
      label: function(n, newLabel) {
        var label, value, _ref;

        _ref = this.popCmt(), value = _ref.value, label = _ref.label;
        return this.write(this.r[SP] + (n + 1), value, newLabel != null ? newLabel : label);
      }
    },
    ldl: {
      normal: function(n) {
        return this.push(this.read(this.r[MP] + n));
      },
      label: function(n, newLabel) {
        this.push(this.read(this.r[MP] + n), newLabel != null ? newLabel : this.mem.label[this.r[MP] + n]);
        return this.mem.read[this.r[MP] + n] = true;
      }
    },
    stl: {
      normal: function(n) {
        var value;

        value = this.pop();
        return this.write(this.r[MP] + n, value);
      },
      label: function(n, newLabel) {
        var label, value, _ref;

        _ref = this.popCmt(), value = _ref.value, label = _ref.label;
        return this.write(this.r[MP] + n, value, newLabel != null ? newLabel : label);
      }
    },
    brt: function(addr) {
      if (this.pop() === 1) {
        return this.jump(addr);
      }
    },
    brf: function(addr) {
      if (this.pop() !== 1) {
        return this.jump(addr);
      }
    },
    bra: function(addr) {
      return this.jump(addr);
    },
    bsr: function(addr) {
      this.push(this.r[PC], "PC return");
      return this.jump(addr);
    },
    link: function(n) {
      var _i, _results;

      this.push(this.r[MP], "MP return");
      this.r[MP] = this.r[SP];
      _results = [];
      for (_i = 0; 0 <= n ? _i < n : _i > n; 0 <= n ? _i++ : _i--) {
        _results.push(this.push(0));
      }
      return _results;
    },
    unlink: function() {
      this.r[SP] = this.r[MP];
      return this.r[MP] = this.pop();
    },
    ret: function(addr) {
      return this.r[PC] = this.pop();
    },
    ajs: function(n) {
      return this.r[SP] += n;
    },
    halt: function() {
      return this.halted = true;
    },
    annote: function(regHandle, low, high, color, text) {
      var i, reg, _i, _ref, _ref1, _results;

      console.log(regHandle);
      reg = this.regId(regHandle);
      console.log(this.r[reg], low, high, color, text);
      _results = [];
      for (i = _i = _ref = this.r[reg] + low, _ref1 = this.r[reg] + high; _ref <= _ref1 ? _i <= _ref1 : _i >= _ref1; i = _ref <= _ref1 ? ++_i : --_i) {
        console.log(i);
        _results.push(this.mem.annote[i] = {
          color: color,
          text: text
        });
      }
      return _results;
    },
    nop: function() {},
    trap: function(n) {
      var _this = this;

      return [
        (function() {
          return View.print(_this.peek());
        })
      ][n]();
    }
  };

  PC = 0;

  SP = 1;

  MP = 2;

  HP = 3;

  RR = 4;

  MemoryBank = (function() {
    function MemoryBank(length) {
      var buffer;

      this.buffer = buffer = new ArrayBuffer(length);
      this.f64 = new Float64Array(buffer);
      this.u32 = new Uint32Array(buffer);
      this.i32 = new Int32Array(buffer);
      this.f32 = new Float32Array(buffer);
      this.u16 = new Uint16Array(buffer);
      this.i16 = new Int16Array(buffer);
      this.u8 = new Uint8Array(buffer);
      this.i8 = new Int8Array(buffer);
      this.annote = {};
      this.label = {};
      this.written = {};
      this.read = {};
      this.raw = this.u32;
      this.int = this.i32;
      this.float = this.f32;
    }

    return MemoryBank;

  })();

  global.SimpleCPU = (function() {
    function SimpleCPU(instructions) {
      this.instructions = instructions;
      this.code = [];
      this.labels = true;
      this.reset();
    }

    SimpleCPU.prototype.reset = function() {
      this.memSize = 1024;
      this.memSeen = -1;
      this.mem = new MemoryBank(4 * this.memSize);
      this.regCount = 8;
      this.reg = new MemoryBank(4 * this.regCount);
      this.r = this.reg.int;
      this.r[PC] = 0;
      this.r[SP] = -1;
      this.r[MP] = -1;
      this.r[HP] = -1;
      this.halted = false;
      return this.setLineNr();
    };

    SimpleCPU.prototype.setLineNr = function() {
      var _ref, _ref1;

      return this.lineNr = (_ref = (_ref1 = this.code[this.r[PC]]) != null ? _ref1.lineNr : void 0) != null ? _ref : false;
    };

    SimpleCPU.prototype.write = function(addr, value, label) {
      this.mem.int[addr] = value;
      this.mem.label[addr] = label;
      return this.mem.written[addr] = true;
    };

    SimpleCPU.prototype.read = function(addr) {
      return this.mem.int[addr];
    };

    SimpleCPU.prototype.jump = function(addr) {
      var _ref, _ref1;

      this.r[PC] = this.labels[addr];
      return this.lineNr = (_ref = (_ref1 = this.code[this.r[PC]]) != null ? _ref1.lineNr : void 0) != null ? _ref : false;
    };

    SimpleCPU.prototype.pop = function() {
      return this.read(this.r[SP]--);
    };

    SimpleCPU.prototype.popCmt = function() {
      return {
        value: this.read(this.r[SP]),
        label: this.mem.label[this.r[SP]--]
      };
    };

    SimpleCPU.prototype.push = function(value, label) {
      this.write(++this.r[SP], value, label);
      return this.memSeen = Math.max(this.memSeen, this.r[SP]);
    };

    SimpleCPU.prototype.peek = function() {
      return this.read(this.r[SP]);
    };

    SimpleCPU.prototype.set = function(n, value, label) {
      this.reg.int[n] = value;
      this.reg.label[n] = label;
      return this.reg.written[n] = true;
    };

    SimpleCPU.prototype.regId = function(handle) {
      var _ref;

      return (_ref = {
        pc: PC,
        sp: SP,
        mp: MP,
        hp: HP,
        rr: RR
      }[(new String(handle)).toLowerCase()]) != null ? _ref : handle;
    };

    SimpleCPU.prototype.regName = function(id) {
      var _ref;

      return (_ref = ["pc", "sp", "mp", "hp", "rr"][id]) != null ? _ref.toUpperCase() : void 0;
    };

    SimpleCPU.prototype.regVal = function(selector) {
      var id;

      if (+selector === selector) {
        id = selector;
      } else {
        id = this.regId(selector);
      }
      return this.r[id];
    };

    SimpleCPU.prototype.get = function(n) {
      return this.r[n];
    };

    SimpleCPU.prototype.load = function(code) {
      var addr, instruction, _i, _len, _ref, _ref1, _results;

      this.code = code;
      this.lineNr = (_ref = this.code[this.r[PC]]) != null ? _ref.lineNr : void 0;
      this.labels = {};
      addr = 0;
      _ref1 = this.code;
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        instruction = _ref1[_i];
        if (instruction.label) {
          this.labels[instruction.label] = addr;
        }
        _results.push(addr++);
      }
      return _results;
    };

    SimpleCPU.prototype.run = function() {
      while (this.step() === true) {
        continue;
      }
      this.mem.read = {};
      this.mem.written = {};
      this.reg.read = {};
      this.reg.written = {};
      return true;
    };

    SimpleCPU.prototype.step = function() {
      var instruction, _ref;

      if (this.halted) {
        return false;
      }
      instruction = this.code[this.r[PC]++];
      if (instruction == null) {
        this.lineNr = false;
        this.r[PC]--;
        return false;
      }
      this.exec(instruction);
      this.lineNr = (_ref = this.code[this.r[PC]]) != null ? _ref.lineNr : void 0;
      return true;
    };

    SimpleCPU.prototype.exec = function(instruction) {
      var args, tmp, _ref, _ref1;

      if (this.instructions[instruction.opcode] == null) {
        throw new Error("Unknown opcode " + instruction.opcode);
      }
      tmp = this.instructions[instruction.opcode];
      if (this.labels) {
        args = [].concat(instruction.args, instruction.hint.label);
        ((_ref = tmp.label) != null ? _ref : tmp).apply(this, args);
      } else {
        ((_ref1 = tmp.normal) != null ? _ref1 : tmp).apply(this, instruction.args);
      }
    };

    return SimpleCPU;

  })();

}).call(this);

/*
//@ sourceMappingURL=cpu.map
*/
